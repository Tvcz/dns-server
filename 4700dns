#!/usr/bin/env -S python3 -u

import argparse
import os
import socket
import time
import json
import select
import struct
import sys
import math
from dnslib import DNSRecord, DNSHeader, RR, QTYPE, A, DNSQuestion
from typing import Any, TypeAlias
import glob

_Address: TypeAlias = Any

ENABLE_LOG = True

if ENABLE_LOG:
    for log_file in glob.glob("log-*.txt"):
        os.remove(log_file)


def log(id, message):
    if not ENABLE_LOG:
        return
    with open(f"log-{id}.txt", "a+") as f:
        timestamp = time.strftime("%H:%M:%S") + \
            f".{int(time.time() * 1000) % 1000:03d}"
        f.write(f"[{timestamp}] {message}\n")
        pass


class Query:
    def __init__(self, client_record: DNSRecord, client_addr: _Address, request_id: int):
        self.client_record = client_record
        self.client_addr = client_addr
        self.id = request_id
        self.cnames = []

    def add_cname(self, cname: RR):
        self.cnames.append(cname)

    def has_chain(self):
        return len(self.cnames) > 0


class Server:
    def __init__(self, root_ip, zone_file_path, port):
        self.root_ip = root_ip
        self.zone_file_path = zone_file_path

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(("0.0.0.0", port))
        self.port = self.socket.getsockname()[1]

        self.log(f"Bound to port {self.port}")

        self.parse_zone_file()

        self.ongoing_queries: dict[int, Query] = {}

    def parse_zone_file(self):
        zone_files_string = open(self.zone_file_path).read()
        self.records = RR.fromZone(zone_files_string)
        for record in self.records:
            self.log(f"Loaded record: {record}")

    def log(self, message: str):
        sys.stderr.write(message + "\n")
        sys.stderr.flush()

    def send_to_server(self, ip: str, message: DNSRecord):
        self.send((ip, 60053), message)

    def send(self, addr: _Address, message: DNSRecord):
        self.log(f"Sending message to {addr}:\n{message}")
        self.socket.sendto(message.pack(), addr)

    def recv(self, socket: socket.socket):
        data, addr = socket.recvfrom(65535)

        # Unpack the DNS request
        request = DNSRecord.parse(data)
        self.log(f"Received message from {addr}:\n{request}")

        # Handle the request
        self.handle_message(request, addr)

    def handle_message(self, message: DNSRecord, ret_addr: _Address):
        if message.header.qr == 0:
            self.handle_request(message, ret_addr)
        else:
            self.handle_response(message, ret_addr)

    def handle_request(self, dns_record: DNSRecord, client_addr: _Address):
        if dns_record.q.qname in [record.rname for record in self.records]:
            self.handle_authoritative_request(dns_record, client_addr)
        else:
            self.handle_recursive_request(dns_record, client_addr)

    def matches_type(self, question: DNSQuestion, record: RR):
        return question.qtype == record.rtype

    def matches(self, question: DNSQuestion, record: RR):
        return question.qname == record.rname and question.qtype == record.rtype

    def handle_authoritative_request(self, dns_record: DNSRecord, client_addr: _Address):
        response = dns_record.reply()
        self.add_answers_to_response(dns_record, response)
        self.add_authority_to_response(response)
        self.add_additional_to_response(response)
        self.send(client_addr, response)

    def add_answers_to_response(self, dns_record: DNSRecord, response: DNSRecord):
        for record in self.records:
            same_name = record.rname == dns_record.q.qname
            same_type = record.rtype == dns_record.q.qtype
            if same_name and same_type:
                response.add_answer(record)

    def add_authority_to_response(self, response: DNSRecord):
        auth_added = False
        auth_domain = str(response.q.qname)
        while not auth_added:
            if auth_domain == "":
                break
            for record in self.records:
                if str(record.rname) == auth_domain and record.rtype == QTYPE.NS:
                    response.add_auth(record)
                    auth_added = True
            auth_domain = ".".join(auth_domain.split(".")[1:])

    def add_additional_to_response(self, response: DNSRecord):
        for record in self.records:
            if record.rtype == QTYPE.CNAME or record.rtype == QTYPE.NS:
                for rec in self.records:
                    if rec.rname == record.rdata and rec.rtype == QTYPE.A:
                        response.add_ar(rec)

    def handle_recursive_request(self, incoming_record: DNSRecord, client_addr: _Address):
        if incoming_record.header.rd == 0:
            self.send_servfail(incoming_record, client_addr)
            return
        domain = incoming_record.q.qname
        record_type = QTYPE[incoming_record.q.qtype]
        request = DNSRecord.question(domain, record_type)
        record_id = incoming_record.header.id
        request_id = request.header.id
        log(record_id,
            f"Received request for {domain} of type {record_type} from {client_addr}")
        log(record_id, f"Sending request to {self.root_ip}")
        log(record_id, f"Request:\n{request}")
        self.send_to_server(self.root_ip, request)
        self.ongoing_queries[request_id] = Query(
            incoming_record, client_addr, record_id)

    def send_servfail(self, query: Query):
        response = query.client_record.reply()
        response.header.rcode = 2
        self.send(query.client_addr, response)
        self.log("Sending SERVFAIL, recursion flag not set")

    def handle_response(self, incoming_record: DNSRecord, server_addr: _Address):
        if incoming_record.header.id in self.ongoing_queries:
            query = self.ongoing_queries[incoming_record.header.id]
            log(query.id,
                f"Received response from {server_addr} for {incoming_record.q.qname}")
            log(query.id, f"Response:\n{incoming_record}")
            del self.ongoing_queries[incoming_record.header.id]
            if incoming_record.header.aa == 1:
                follow_chain = True
                for answer in incoming_record.rr:
                    if self.matches_type(query.client_record.q, answer):
                        follow_chain = False
                if follow_chain:
                    self.handle_cname_response(incoming_record, query)
                else:
                    self.send_authoritative_response(incoming_record, query)
            elif incoming_record.header.auth == 1:
                for auth_record in incoming_record.auth:
                    if self.matches(query.client_record.q, auth_record):
                        self.send_authoritative_response(
                            incoming_record, query)
                self.forward_non_authoritative_response(incoming_record, query)
            elif incoming_record.header.rcode == 2:
                self.send_servfail(query)
            else:
                self.forward_non_authoritative_response(incoming_record, query)
        else:
            log(0, f"Received response for unknown query:\n{incoming_record}")

    def handle_cname_response(self, incoming_record: DNSRecord, query: Query):
        log(query.id, "CNAME response, looking for next hop")
        for answer in incoming_record.rr:
            if answer.rtype == QTYPE.CNAME:
                domain = str(answer.rdata)
                record_type = QTYPE[query.client_record.q.qtype]
                request = query.client_record.question(domain, record_type)
                for answer in incoming_record.rr:
                    if answer.rtype == QTYPE.CNAME:
                        query.add_cname(answer)
                self.ongoing_queries[request.header.id] = query
                self.send_to_server(self.root_ip, request)
                log(query.id,
                    f"Forwarding to {self.root_ip} for {domain} of type {record_type}")
                return
        log(query.id, "No CNAME record found")

    def send_authoritative_response(self, incoming_record: DNSRecord, query: Query):
        log(query.id, "Authoritative response, sending to client")
        response = query.client_record.reply()
        response.header.aa = 0
        for cname in query.cnames:
            response.add_answer(cname)
        for answer in incoming_record.rr:
            response.add_answer(answer)
        for auth in incoming_record.auth:
            response.add_auth(auth)
        for additional in incoming_record.ar:
            response.add_ar(additional)
        self.send(query.client_addr, response)

    def forward_non_authoritative_response(self, incoming_record: DNSRecord, query: Query):
        log(query.id,
            f"Non-authoritative response, looking for next hop...")
        # todo: fix assumption that the first A record in the additional section
        # is the next hop (and that there is always an A record in the additional section)
        if incoming_record.ar:
            for additional in incoming_record.ar:
                if additional.rtype == QTYPE.A:
                    next_hop_ip = str(additional.rdata)
                    domain = query.client_record.q.qname
                    # If the query has a chain of CNAMEs, use the last CNAME as
                    # the domain target instead of the original query
                    if query.has_chain():
                        domain = str(query.cnames[-1].rdata)
                    record_type = QTYPE[query.client_record.q.qtype]
                    request = query.client_record.question(domain, record_type)
                    self.send_to_server(next_hop_ip, request)
                    log(query.id,
                        f"Forwarding to {next_hop_ip} for {domain} of type {record_type}")
                    self.ongoing_queries[request.header.id] = query
                    return
        log(query.id, "No additional section with A record found")

    def run(self):
        seq = 0
        while True:
            socks = select.select([self.socket], [], [], 0.1)[0]
            for conn in socks:
                self.recv(conn)

        return


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='send data')
    parser.add_argument('root_ip', type=str,
                        help="The IP address of the root server")
    parser.add_argument('zone', type=str, help="The zone file for this server")
    parser.add_argument('--port', type=int,
                        help="The port this server should bind to", default=0)
    args = parser.parse_args()
    sender = Server(args.root_ip, args.zone, args.port)
    sender.run()
