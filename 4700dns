#!/usr/bin/env -S python3 -u

import argparse
import os
import socket
import time
import json
import select
import struct
import sys
import math
from dnslib import DNSRecord, DNSHeader, RR, QTYPE, A, DNSQuestion
from typing import Any, TypeAlias
import glob

_Address: TypeAlias = Any

ENABLE_LOG = True

if ENABLE_LOG:
    for log_file in glob.glob("log-*.txt"):
        os.remove(log_file)


def log(id, message):
    if not ENABLE_LOG:
        return
    with open(f"log-{id}.txt", "a+") as f:
        timestamp = time.strftime("%H:%M:%S") + \
            f".{int(time.time() * 1000) % 1000:03d}"
        f.write(f"[{timestamp}] {message}\n")
        pass


class Query:
    def __init__(self, client_record: DNSRecord, client_addr: _Address, request_id: int):
        self.client_record = client_record
        self.client_addr = client_addr
        self.id = request_id
        self.cnames: list[RR] = []
        self.active_zone: str = "."

    def add_cname(self, cname: RR):
        self.cnames.append(cname)

    def has_chain(self):
        return len(self.cnames) > 0

    def set_current_zone(self, zone: str):
        self.active_zone = zone

    def reset_current_zone(self):
        self.active_zone = "."


class Server:
    def __init__(self, root_ip, zone_file_path, port):
        self.root_ip = root_ip
        self.zone_file_path = zone_file_path

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(("0.0.0.0", port))
        self.port = self.socket.getsockname()[1]

        self.log(f"Bound to port {self.port}")

        self.parse_zone_file()

        self.ongoing_queries: dict[int, Query] = {}

        self.cache: dict[str, (RR, float)] = {}

    def parse_zone_file(self):
        zone_files_string = open(self.zone_file_path).read()
        self.records = RR.fromZone(zone_files_string)
        for record in self.records:
            self.log(f"Loaded record: {record}")

    def log(self, message: str):
        sys.stderr.write(message + "\n")
        sys.stderr.flush()

    def send(self, addr: _Address, message: DNSRecord):
        self.log(f"Sending message to {addr}:\n{message}")
        self.socket.sendto(message.pack(), addr)

    def send_to_server(self, ip: str, message: DNSRecord):
        self.send((ip, 60053), message)

    def ask_question(self, question: DNSRecord, server_addr: _Address):
        self.send_to_server(server_addr, question)

    def recv(self, socket: socket.socket):
        data, addr = socket.recvfrom(65535)

        # Unpack the DNS request
        request = DNSRecord.parse(data)
        self.log(f"Received message from {addr}:\n{request}")

        # Handle the request
        self.handle_message(request, addr)

    def handle_message(self, message: DNSRecord, ret_addr: _Address):
        if message.header.qr == 0:
            self.handle_request(message, ret_addr)
        else:
            filtered_message = self.bailiwick_filter(message)
            self.update_cache(filtered_message)
            self.handle_response(filtered_message, ret_addr)

    def update_cache(self, dns_record: DNSRecord):
        for record in dns_record.rr:
            key = self.cache_format_record(record)
            self.cache[key] = (record, time.time())
        for record in dns_record.auth:
            key = self.cache_format_record(record)
            self.cache[key] = (record, time.time())
        for record in dns_record.ar:
            key = self.cache_format_record(record)
            self.cache[key] = (record, time.time())

    def bailiwick_filter(self, dns_record: DNSRecord):
        query = self.ongoing_queries[dns_record.header.id]
        dns_record.rr = self.filter(dns_record.rr, query)
        dns_record.auth = self.filter(dns_record.auth, query)
        dns_record.ar = self.filter(dns_record.ar, query)
        return dns_record

    def filter(self, records: list[RR], query: Query):
        filtered = []
        for record in records:
            if str(record.rname).endswith(query.active_zone):
                filtered.append(record)
            else:
                log(query.id,
                    f"Filtered {record} based on zone {query.active_zone}")
        return filtered

    def handle_request(self, dns_record: DNSRecord, client_addr: _Address):
        self.clean_cache()
        if dns_record.q.qname in [record.rname for record in self.records]:
            self.handle_authoritative_request(dns_record, client_addr)
        elif self.cache_format_question(dns_record.q) in self.cache:
            self.handle_cached_request(dns_record, client_addr)
        else:
            self.handle_recursive_request(dns_record, client_addr)

    def cache_format_question(self, question: DNSQuestion) -> str:
        return f"{question.qname}|{question.qtype}"

    def cache_format_record(self, record: RR) -> str:
        return f"{record.rname}|{record.rtype}"

    def clean_cache(self):
        now = time.time()
        for key in list(self.cache.keys()):
            record, timestamp = self.cache[key]
            if now - timestamp > record.ttl:
                del self.cache[key]

    def handle_cached_request(self, dns_record: DNSRecord, client_addr: _Address):
        response = self.response_from_records(
            dns_record, [val[0] for val in self.cache.values()])
        self.send(client_addr, response)

    def matches_type(self, question: DNSQuestion, record: RR):
        return question.qtype == record.rtype

    def matches(self, question: DNSQuestion, record: RR):
        return question.qname == record.rname and question.qtype == record.rtype

    def handle_authoritative_request(self, dns_record: DNSRecord, client_addr: _Address):
        response = self.response_from_records(
            dns_record, self.records, authority=True)
        self.send(client_addr, response)

    def response_from_records(self, dns_record: DNSRecord, records: list[RR], authority=False):
        response = dns_record.reply()
        response.header.aa = 1 if authority else 0
        self.add_answers_to_response(dns_record, response, records)
        self.add_authority_to_response(response, records)
        self.add_additional_to_response(response, records)
        return response

    def add_answers_to_response(self, dns_record: DNSRecord, response: DNSRecord, records: list[RR]):
        for record in records:
            same_name = record.rname == dns_record.q.qname
            same_type = record.rtype == dns_record.q.qtype
            if same_name and same_type:
                response.add_answer(record)

    def add_authority_to_response(self, response: DNSRecord, records: list[RR]):
        auth_added = False
        auth_domain = str(response.q.qname)
        if response.q.qtype == QTYPE.NS:
            return
        while not auth_added:
            if auth_domain == "":
                break
            for record in records:
                if str(record.rname) == auth_domain and record.rtype == QTYPE.NS:
                    response.add_auth(record)
                    auth_added = True
            auth_domain = ".".join(auth_domain.split(".")[1:])

    def add_additional_to_response(self, response: DNSRecord, records: list[RR]):
        for record in response.rr:
            if record.rtype == QTYPE.CNAME or record.rtype == QTYPE.NS:
                for rec in records:
                    log(-1, f"Checking {rec.rname} == {record.rdata}")
                    if str(rec.rname) == str(record.rdata) and rec.rtype == QTYPE.A:
                        response.add_ar(rec)

    def handle_recursive_request(self, incoming_record: DNSRecord, client_addr: _Address):
        if incoming_record.header.rd == 0:
            self.send_servfail(incoming_record, client_addr)
            return
        domain = incoming_record.q.qname
        record_type = QTYPE[incoming_record.q.qtype]
        question_request = DNSRecord.question(domain, record_type)
        record_id = incoming_record.header.id
        request_id = question_request.header.id
        log(record_id,
            f"Received request for {domain} of type {record_type} from {client_addr}")
        log(record_id, f"Sending request to {self.root_ip}")
        log(record_id, f"Request:\n{question_request}")
        self.ongoing_queries[request_id] = Query(
            incoming_record, client_addr, record_id)
        self.ask_question(question_request, self.root_ip)

    def send_servfail(self, query: Query):
        response = query.client_record.reply()
        response.header.rcode = 2
        self.send(query.client_addr, response)
        self.log("Sending SERVFAIL, recursion flag not set")

    def handle_response(self, incoming_record: DNSRecord, server_addr: _Address):
        if incoming_record.header.id in self.ongoing_queries:
            query = self.ongoing_queries[incoming_record.header.id]
            log(query.id,
                f"Received response from {server_addr} for {incoming_record.q.qname}")
            log(query.id, f"Response:\n{incoming_record}")
            del self.ongoing_queries[incoming_record.header.id]
            if len(incoming_record.auth) == 0 and len(incoming_record.rr) == 0 and len(incoming_record.ar) == 0:
                log(query.id, "No records found, returning empty response")
                self.send_authoritative_response(incoming_record, query)
            elif incoming_record.header.aa == 1:
                has_match = False
                has_cname = False
                for answer in incoming_record.rr:
                    if self.matches_type(query.client_record.q, answer):
                        has_match = True
                    if answer.rtype == QTYPE.CNAME:
                        has_cname = True
                if not has_match and has_cname:
                    self.handle_cname_response(incoming_record, query)
                else:
                    self.send_authoritative_response(incoming_record, query)
            elif incoming_record.header.auth == 1:
                for auth_record in incoming_record.auth:
                    if self.matches(query.client_record.q, auth_record):
                        self.send_authoritative_response(
                            incoming_record, query)
                self.forward_non_authoritative_response(incoming_record, query)
            elif incoming_record.header.rcode == 2:
                self.send_servfail(query)
            else:
                self.forward_non_authoritative_response(incoming_record, query)
        else:
            log(0, f"Received response for unknown query:\n{incoming_record}")

    def handle_cname_response(self, incoming_record: DNSRecord, query: Query):
        log(query.id, "CNAME response, looking for next hop")
        for answer in incoming_record.rr:
            if answer.rtype == QTYPE.CNAME:
                domain = str(answer.rdata)
                record_type = QTYPE[query.client_record.q.qtype]
                question_request = DNSRecord.question(domain, record_type)
                for answer in incoming_record.rr:
                    if answer.rtype == QTYPE.CNAME:
                        query.add_cname(answer)
                query.reset_current_zone()
                self.ongoing_queries[question_request.header.id] = query
                self.ask_question(question_request, self.root_ip)
                log(query.id,
                    f"Forwarding to {self.root_ip} for {domain} of type {record_type}")
                return
        log(query.id, "No CNAME record found")

    def send_authoritative_response(self, incoming_record: DNSRecord, query: Query):
        log(query.id, "Authoritative response, sending to client")
        response = query.client_record.reply()
        response.header.aa = 0
        for cname in query.cnames:
            response.add_answer(cname)
        for answer in incoming_record.rr:
            response.add_answer(answer)
        for auth in incoming_record.auth:
            response.add_auth(auth)
        for additional in incoming_record.ar:
            response.add_ar(additional)
        self.send(query.client_addr, response)

    def forward_non_authoritative_response(self, incoming_record: DNSRecord, query: Query):
        log(query.id,
            f"Non-authoritative response, looking for next hop...")
        # todo: fix assumption that the first A record in the additional section
        # is the next hop (and that there is always an A record in the additional section)
        if incoming_record.ar:
            for additional in incoming_record.ar:
                if additional.rtype == QTYPE.A:
                    self.update_query_zone(
                        query, incoming_record, str(additional.rname))
                    next_hop_ip = str(additional.rdata)
                    domain = query.client_record.q.qname
                    # If the query has a chain of CNAMEs, use the last CNAME as
                    # the domain target instead of the original query
                    if query.has_chain():
                        domain = str(query.cnames[-1].rdata)
                    record_type = QTYPE[query.client_record.q.qtype]
                    question_request = DNSRecord.question(domain, record_type)
                    self.ongoing_queries[question_request.header.id] = query
                    self.ask_question(question_request, next_hop_ip)
                    log(query.id,
                        f"Forwarding to {next_hop_ip} for {domain} of type {record_type}")
                    return
        log(query.id, "No additional section with A record found")

    def update_query_zone(self, query: Query, incoming_record: DNSRecord, next_hop_domain: str):
        zone = next_hop_domain
        if incoming_record.auth:
            for auth in incoming_record.auth:
                if str(auth.rdata) == next_hop_domain:
                    zone = str(auth.rname)
        log(query.id, f"Updating zone to {zone}")
        query.set_current_zone(zone)

    def run(self):
        seq = 0
        while True:
            socks = select.select([self.socket], [], [], 0.1)[0]
            for conn in socks:
                self.recv(conn)

        return


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='send data')
    parser.add_argument('root_ip', type=str,
                        help="The IP address of the root server")
    parser.add_argument('zone', type=str, help="The zone file for this server")
    parser.add_argument('--port', type=int,
                        help="The port this server should bind to", default=0)
    args = parser.parse_args()
    sender = Server(args.root_ip, args.zone, args.port)
    sender.run()
